1.  Introduccion a ReactJS
ReactJS es una libreria para crear interfaces de usuario

ReactJS ofrece grandes beneficios en performance, modularidad y promueve un flujo muy claro de datos y eventos, facilitando la planeación y desarrollo de apps complejas.

ReactJS es una librería enfocada en la visualización. Si estamos iniciando un proyecto podemos basarnos en la arquitectura Flux, pero si ya tenemos un proyecto usando un Framework MVC como AngularJS podemos dejar AngularJS como Controlador y que ReactJS se encargue de las vistas.

El secreto de ReactJS para tener un performance muy alto, es que implementa algo llamado Virtual DOM y en vez de renderizar todo el DOM en cada cambio, que es lo que normalmente se hace, este hace los cambios en una copia en memoria y después usa un algoritmo para comparar las propiedades de la copia en memoria con las de la versión del DOM y así aplicar cambios exclusivamente en las partes que varían.

Los Components son el corazon de ReactJS (Tienen la funcion de los usar datos y no como lo tienen que usar)

ReactJS nos ofrece un pseudolenguaje llamado JSX que facilita el desarrollo de aplicaciones web con su sintaxis para crear elementos en el DOM.

No podemos usar directamente el JSX, pero tenemos dos opciones para compilarlo Usando JSXTransformer que hace la conversión directamente en el navegador del programador. Para producción se recomienda usar el precompilador basado en NodeJS que nos genera JavaScript nativo y evita que el JSX tenga que ser compilado por el usuario.

- React Developer Tools Extension (Extension de Google Chrome - Habilitar [Perimitir acceso a URL de archivo])

1.1.    Sintaxis JSX
- No es recomendable renderizar en el body
- En JSX los atributos se llaman Props

- Instalacion
<script src="https://fb.me/react-0.13.3.min.js"></script>
<script src="https://fb.me/JSXTransformer-0.13.3.js"></script>

npm install -g react-tools
	var React = require('react');
	React.render(...);

bower install --save react

- /hw.html
<script type="text/jsx">
var HelloWorldComponent = React.createClass({
	render: function() {
		return (
			<h1>Hello { this.props.name }!</h1>
		);
	}
});
React.render(<HelloWorldComponent name={ "Miguel" } />, document.getElementById('container'));

setTimeout(function () {
	React.render(<HelloWorldComponent name={ "Pepe" } />, document.getElementById('container'));
}, 4000);
</script>

-- ES6
<script type="text/jsx;harmony=true">
class HelloWorldComponent extends React.Component{
	render() {
		return (
			<h1>Hello { this.props.name }!</h1>
		);
	}
};
React.render(<HelloWorldComponent name={ "Miguel" } />, document.getElementById('container'));

setTimeout(() => {
	React.render(<HelloWorldComponent name={ "Pepe" } />, document.getElementById('container'));
}, 5000);
</script>

- Herramientas para desarrolladores -> React[Tab]


1.2.    Props
- Propiedades (Atributos) de un Componente

- /props/index.html
<script src="https://fb.me/react-0.13.3.min.js"></script>
<script src="https://fb.me/JSXTransformer-0.13.3.js"></script>

<section id="container"></section>
<script type="text/jsx;harmony=true" src="js/script-es6.js"></script>

- /props/js/script-es6.js
var pokemons = [
	{ name: "Abra", number: 63 },
	{ name: "Charmander", number: 4 },
	{ name: "Bulbasaur", number: 1 },
	{ name: "Gastly", number: 92 }
];

class Avatar extends React.Component{
	render () {
		var classString = 'avatar';
		var url = `http://veekun.com/dex/media/pokemon/main-sprites/x-y/${ this.props.number }.png`;
		return (
			<img src={ url } className={ classString } />
		);
	}
};
Avatar.propTypes = {
	number: React.PropTypes.number 
};

class PokeRow extends React.Component{
	render() {
		return (
			<div>
				<Avatar number={ this.props.number } />
				<span className={ "avatar-name" } >{ this.props.name }</span>
			</div>
		);
	}
};

PokeRow.propTypes = {
	name: React.PropTypes.string,
	number: React.PropTypes.number
};

var pokemon = pokemons[1];
React.render(<PokeRow name={ pokemon.name } number={ pokemon.number } />, document.getElementById('container'));


1.3.    Componiendo Componentes
- /props/js/script-es6.js
class PokeTable extends React.Component{
	render() {
		return (
			<ul className={ "poke-table" }>
			{
				this.props.pokemons.map((pokemon) => {
					return (<PokeRow key={ pokemon.number } name={ pokemon.name } number={ pokemon.number } />);
				})
			}
			</ul>
		);
	}
};

React.render(<PokeTable pokemons={ pokemons } />, document.getElementById('container'));


2.  Ciclo de vida de un componente, States, Props y Browserify
2.1.    Instalacion de Browserify
- Browserify permite implementar módulos en el lado del cliente muy familiar a lo que hace Node.js.
Se puede exportar módulos o requerir de ellos en diversos archivos. Ademas permite utilizar módulos del core de Node.js y demás módulos que se encuentra en NPM.

- /pokechat/components/PokeAvatar.js
import React from "react";

class PokeAvatar extends React.Component{
	render () {
		var classString = 'avatar';
		var url = `http://veekun.com/dex/media/pokemon/main-sprites/x-y/${ this.props.number }.png`;
		console.log(url);
		
		return (
			<img src={ url } className={ classString } />
		);
	}
};

PokeAvatar.propTypes = {
	number: React.PropTypes.number 
};

export default PokeAvatar;

- /pokechat/components/PokeRow.js
import React from "react";
import PokeAvatar from "./PokeAvatar";

class PokeRow extends React.Component{
	render() {
		return (
			<li>
				<PokeAvatar number={ this.props.number } />
				<span className={ "avatar-name" } >{ this.props.name }</span>
			</li>
		);
	}
};

PokeRow.propTypes = {
	name: React.PropTypes.string,
	number: React.PropTypes.number
};

export default PokeRow;

- /pokechat/components/PokeTable.js
import React from "react";
import PokeRow from "./PokeRow";

class PokeTable extends React.Component{
	render() {
		return (
			<ul className={ "poke-table" }>
			{
				this.props.pokemons.map((pokemon) => {
					return (<PokeRow key={ pokemon.number } name={ pokemon.name } number={ pokemon.number } />);
				})
			}
			</ul>
		);
	}
};

PokeTable.propTypes = {
	pokemons: React.PropTypes.array
};

export default PokeTable;

- /pokechat/app.js
import React from "react";
import PokeTable from "./components/PokeTable";

var pokemons = [
	{
		name: "Abra",
		number: 63
	},
	{
		name: "Charmander",
		number: 4
	},
	{
		name: "Bulbasaur",
		number: 1
	},
	{
		name: "Gastly",
		number: 92
	}
];

React.render(<PokeTable pokemons={ pokemons } />, document.getElementById('container'));

- /pokechat/index.html
<section id="container"></section>
<script src="build.js"></script>

- /pokechat/package.json
{
  "name": "pokechat",
  "description": "PokeChat React",
  "dependencies": {
    "babelify": "^6.2.0",
    "browserify": "^11.0.1",
    "react": "^0.13.3"
  },
  "scripts": {
    "build": "browserify app.js -t babelify --outfile build.js"
  }
}

sudo npm install --save browserify
sudo npm install --save babelify
npm run build


2.2.    Teoria sobre ciclos de vida en ReactJS
- defaultProps()
- setState() -> render() [Solo cuando es necesesario]
- setState(data, callback)
- setInitialState()
	- Components
	- No pasar props a state usar constructor
	- Usa JSON
	- No usa Datos calculados - Otros Components - Datos duplicados de las props

- Ciclo de vida de los componentes
	- Mounting ->  se monta en el dom
	- Updating -> se actualiza el componente
	- Unmounting -> se quita el componente del dom

	- Funciones Mounting - Unmounting
	    - componentWillMount() -> Se ejecuta antes que se monte el dom y el componente
	    - componentDidMount() -> Ya se monto - Nos permite integrar librerias con terceros
	    - componentWillReceiveProps() -> Se ejecuta cuando cammbia las props no cuando se llama al render inicial
	    - shouldComponentUpdate() -> Permite incrementar la performance de la app, permite controlar el render de los componentes
	    - componentWillUpdate() -> Preparar algo antes de llamar al render y no al setState
	    - componentDidUpdate() -> Operar sobre lo nuevo del dom
	    - componentWillUnmount() -> Limpiar componentes para liberar memoria
    
    - Mixins
    	- Compartir funcionalidades que tienen en comun distintos componentes, ademas reutilizar la logica de otros componentes y poder ejecutarlos de forma secuencial.

2.3.    Event handling, State y Browserify
2.4.    Integracion con Librerias de terceros

3.  Realtime y rutas con ReactJS
3.1.    Tools CSS_Reset
3.2.    La teoria detras de una aplicacion RealTime
3.3.    RealTime apps en ReactJS
3.4.    Animaciones en ReactJS
3.5.    Complementando con Socket.IO
3.6.    Creacion de rutas con ReactRouter

4.